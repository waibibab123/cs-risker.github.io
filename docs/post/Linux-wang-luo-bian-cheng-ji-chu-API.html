<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/105782835?s=400&u=04c0291bd1e06b01ccad1d53388ed4a8a8894a53&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 前言
内容来源：本文章为阅读《Linux高性能服务器编程》第五章.Linux网络编程基础API所记录的部分笔记。">
<meta property="og:title" content="Linux网络编程基础API">
<meta property="og:description" content="# 前言
内容来源：本文章为阅读《Linux高性能服务器编程》第五章.Linux网络编程基础API所记录的部分笔记。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://waibibab-cs.github.io/post/Linux-wang-luo-bian-cheng-ji-chu-API.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/105782835?s=400&u=04c0291bd1e06b01ccad1d53388ed4a8a8894a53&v=4">
<title>Linux网络编程基础API</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Linux网络编程基础API</h1>
<div class="title-right">
    <a href="https://waibibab-cs.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/waibibab-cs/waibibab-cs.github.io/issues/11" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>前言</h1>
<p>内容来源：本文章为阅读《Linux高性能服务器编程》第五章.Linux网络编程基础API所记录的部分笔记。<br>
摘要：这篇文章围绕 Linux 网络编程基础 API 展开，介绍了 socket 地址（字节序、通用 / 专用地址结构、IP 转换）、socket 创建 / 命名 / 监听 / 接受 / 发起连接的核心函数（socket/bind/listen/accept/connect）、连接关闭的两种方式（close/shutdown），以及 TCP（recv/send、带外数据）和 UDP（recvfrom/sendto）的数据读写接口。</p>
<h1>1.socket地址API</h1>
<h2>1.1 主机字节序和网络字节序</h2>
<p>一、字节序的核心概念</p>
<ol>
<li><strong>定义</strong>：多字节数据（如 32 位整数）在内存中的存储顺序，分为两种：
<ul>
<li><strong>大端字节序</strong>：高位字节存在内存低地址，低位字节存在高地址；</li>
<li><strong>小端字节序</strong>：高位字节存在内存高地址，低位字节存在低地址。</li>
</ul>
</li>
<li><strong>影响</strong>：不同字节序的主机直接传递数据，会导致接收端解析错误。</li>
</ol>
<p>二、主机字节序与网络字节序</p>
<ol>
<li><strong>主机字节序</strong>：当前机器的字节序（现代 PC 大多是小端）；</li>
<li><strong>网络字节序</strong>：网络传输的统一标准（强制为大端），解决不同主机字节序不兼容的问题。</li>
</ol>
<p>三、字节序的适用场景</p>
<ul>
<li>跨主机通信：必须将数据转为网络字节序（大端）后传输，接收端再转为主机字节序；</li>
<li>同一主机的跨语言进程通信：比如 C（小端）与 Java（JVM 默认大端）通信，也需处理字节序。</li>
</ul>
<p>四、Linux 下的字节序转换函数<br>
头文件：<code class="notranslate">&lt;netinet/in.h&gt;</code><br>
4 个核心函数（作用是主机字节序 ↔ 网络字节序）：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>函数名</th>
<th>含义（host ↔ network）</th>
<th>处理数据类型</th>
<th>常用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">htonl</code></td>
<td>长整型（32 位）主机→网络</td>
<td><code class="notranslate">unsigned long</code></td>
<td>转换 IP 地址</td>
</tr>
<tr>
<td><code class="notranslate">htons</code></td>
<td>短整型（16 位）主机→网络</td>
<td><code class="notranslate">unsigned short</code></td>
<td>转换端口号</td>
</tr>
<tr>
<td><code class="notranslate">ntohl</code></td>
<td>长整型（32 位）网络→主机</td>
<td><code class="notranslate">unsigned long</code></td>
<td>解析 IP 地址</td>
</tr>
<tr>
<td><code class="notranslate">ntohs</code></td>
<td>短整型（16 位）网络→主机</td>
<td><code class="notranslate">unsigned short</code></td>
<td>解析端口号</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h2>1.2 通用socket地址</h2>
<p>一、基础 Socket 地址结构：<code class="notranslate">struct sockaddr</code><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105150701.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105150701.png" alt="image.png" style="max-width: 100%;"></a><br>
<strong>定义与成员</strong>：<br>
- 头文件：<code class="notranslate">&lt;bits/socket.h&gt;</code>；<br>
- 成员：<br>
- <code class="notranslate">sa_family</code>：地址族（与协议族对应，如<code class="notranslate">AF_INET</code>对应 IPv4）；<br>
- <code class="notranslate">sa_data[14]</code>：存放 Socket 地址值，但仅 14 字节，空间不足。<br>
二、协议族与地址族的关系</p>
<ul>
<li>协议族（<code class="notranslate">PF_*</code>）与地址族（<code class="notranslate">AF_*</code>）一一对应，且值完全相同（通常混用）；</li>
<li>常见对应关系：<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105150801.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105150801.png" alt="image.png" style="max-width: 100%;"></a><br>
三、<code class="notranslate">struct sockaddr</code>的缺陷：空间不足<br>
不同协议族的地址值长度超过<code class="notranslate">sa_data[14]</code>的容量：</li>
<li><code class="notranslate">PF_UNIX</code>：地址是路径名（最长 108 字节）；</li>
<li><code class="notranslate">PF_INET</code>：地址是 “16 位端口 + 32 位 IPv4”（共 6 字节，虽能放下，但其他协议不够）；</li>
<li><code class="notranslate">PF_INET6</code>：地址是 “端口 + 流标识 + IPv6 + 范围 ID”（共 26 字节）。<br>
四、改进的通用 Socket 地址结构：<code class="notranslate">struct sockaddr_storage</code><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151013.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151013.png" alt="image.png" style="max-width: 100%;"></a><br>
为解决空间不足问题，Linux 新增该结构：</li>
</ul>
<ol>
<li><strong>定义与特点</strong>：
<ul>
<li>头文件：<code class="notranslate">&lt;bits/socket.h&gt;</code>；</li>
<li>成员：
<ul>
<li><code class="notranslate">sa_family</code>：地址族；</li>
<li><code class="notranslate">__ss_align</code>：保证内存对齐；</li>
<li><code class="notranslate">__ss_padding</code>：填充字段，总空间 128 字节（足够容纳所有协议族的地址）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>作用</strong>：提供足够大的空间存放任意协议族的地址，且内存对齐。</li>
</ol>
<h2>1.3 专用socket地址</h2>
<p>一、专用 Socket 地址结构的设计原因<br>
通用结构（<code class="notranslate">sockaddr</code>/<code class="notranslate">sockaddr_storage</code>）操作不便（比如设置 IP / 端口需要位操作），因此 Linux 为<strong>每个协议族设计了专用地址结构</strong>，字段更直观、易操作。<br>
二、各协议族的专用地址结构</p>
<ol>
<li>UNIX 本地域协议族：<code class="notranslate">struct sockaddr_un</code><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151622.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151622.png" alt="image.png" style="max-width: 100%;"></a></li>
</ol>
<ul>
<li>头文件：<code class="notranslate">&lt;sys/un.h&gt;</code>；</li>
<li>成员：
<ul>
<li><code class="notranslate">sun_family</code>：地址族，固定为<code class="notranslate">AF_UNIX</code>；</li>
<li><code class="notranslate">sun_path[108]</code>：本地通信的文件路径名（UNIX 域套接字通过文件路径标识通信端点）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>TCP/IP 协议族：IPv4 专用<code class="notranslate">struct sockaddr_in</code><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151654.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151654.png" alt="image.png" style="max-width: 100%;"></a></li>
</ol>
<ul>
<li>对应协议：TCP/IPv4；</li>
<li>成员：
<ul>
<li><code class="notranslate">sin_family</code>：地址族，固定为<code class="notranslate">AF_INET</code>；</li>
<li><code class="notranslate">sin_port</code>：16 位端口号（需用<code class="notranslate">htons()</code>转为网络字节序）；</li>
<li><code class="notranslate">sin_addr</code>：嵌套的<code class="notranslate">struct in_addr</code>结构体（存储 IPv4 地址）；</li>
</ul>
</li>
<li>嵌套结构<code class="notranslate">struct in_addr</code>：
<ul>
<li><code class="notranslate">s_addr</code>：32 位 IPv4 地址（需用<code class="notranslate">htonl()</code>/<code class="notranslate">inet_addr()</code>转为网络字节序）。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>TCP/IP 协议族：IPv6 专用<code class="notranslate">struct sockaddr_in6</code><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151724.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105151724.png" alt="image.png" style="max-width: 100%;"></a></li>
</ol>
<ul>
<li>对应协议：TCP/IPv6；</li>
<li>成员：
<ul>
<li><code class="notranslate">sin6_family</code>：地址族，固定为<code class="notranslate">AF_INET6</code>；</li>
<li><code class="notranslate">sin6_port</code>：16 位端口号（需用<code class="notranslate">htons()</code>转为网络字节序）；</li>
<li><code class="notranslate">sin6_flowinfo</code>：流信息，通常设为 0；</li>
<li><code class="notranslate">sin6_addr</code>：嵌套的<code class="notranslate">struct in6_addr</code>结构体（存储 IPv6 地址）；</li>
<li><code class="notranslate">sin6_scope_id</code>：范围 ID，实验阶段字段；</li>
</ul>
</li>
<li>嵌套结构<code class="notranslate">struct in6_addr</code>：
<ul>
<li><code class="notranslate">sa_addr[16]</code>：128 位 IPv6 地址（需转为网络字节序）。<br>
三、专用结构的使用规则<br>
所有专用地址结构（如<code class="notranslate">struct sockaddr_in</code>）在调用 Socket API（如<code class="notranslate">bind()</code>/<code class="notranslate">connect()</code>）时，<strong>必须强转为通用结构<code class="notranslate">struct sockaddr*</code></strong>—— 因为 Socket 接口的地址参数类型固定为<code class="notranslate">struct sockaddr</code>。</li>
</ul>
</li>
</ul>
<h2>1.4 IP地址转换函数</h2>
<p>一、IP 地址转换的必要性<br>
人们习惯用<strong>可读性字符串</strong>表示 IP（如 IPv4 的 “点分十进制”、IPv6 的 “十六进制”），但编程中需将其转为<strong>网络字节序的整数形式</strong>才能使用；记录日志时则需反向转换。<br>
二、IPv4 专用转换函数（旧版）<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105152251.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105152251.png" alt="image.png" style="max-width: 100%;"></a><br>
头文件：<code class="notranslate">&lt;arpa/inet.h&gt;</code>，仅支持 IPv4：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">inet_addr</code></td>
<td>点分十进制字符串 → 网络字节序整数</td>
<td>失败返回<code class="notranslate">INADDR_NONE</code></td>
</tr>
<tr>
<td><code class="notranslate">inet_aton</code></td>
<td>点分十进制字符串 → 网络字节序整数（结果存入<code class="notranslate">struct in_addr</code>）</td>
<td>成功返回 1，失败返回 0；比<code class="notranslate">inet_addr</code>更安全（避免<code class="notranslate">INADDR_NONE</code>的歧义）</td>
</tr>
<tr>
<td><code class="notranslate">inet_ntoa</code></td>
<td>网络字节序整数 → 点分十进制字符串</td>
<td>内部用<strong>静态变量</strong>存储结果，不可重入（多次调用会覆盖之前的结果）</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>三、<code class="notranslate">inet_ntoa</code>的不可重入性<br>
由于<code class="notranslate">inet_ntoa</code>用静态变量存结果，多次调用会导致前一次的结果被覆盖：<br>
运行</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">// 示例：两次调用inet_ntoa，szValue1和szValue2会指向同一个静态内存</span>
<span class="pl-smi">char</span><span class="pl-c1">*</span> <span class="pl-s1">szValue1</span> <span class="pl-c1">=</span> <span class="pl-en">inet_ntoa</span>(<span class="pl-s">"1.2.3.4"</span>);
<span class="pl-smi">char</span><span class="pl-c1">*</span> <span class="pl-s1">szValue2</span> <span class="pl-c1">=</span> <span class="pl-en">inet_ntoa</span>(<span class="pl-s">"10.194.71.60"</span>);
<span class="pl-c">// 最终szValue1和szValue2都会输出"10.194.71.60"</span></pre></div>
<p>四、通用转换函数（新版，支持 IPv4/IPv6）<br>
头文件：<code class="notranslate">&lt;arpa/inet.h&gt;</code>，同时支持 IPv4 和 IPv6：<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105152404.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260105152404.png" alt="image.png" style="max-width: 100%;"></a></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">inet_pton</code></td>
<td>字符串 IP → 网络字节序整数</td>
<td>- <code class="notranslate">af</code>：地址族（<code class="notranslate">AF_INET</code>=IPv4，<code class="notranslate">AF_INET6</code>=IPv6）<br>- <code class="notranslate">src</code>：字符串 IP<br>- <code class="notranslate">dst</code>：存储结果的内存</td>
</tr>
<tr>
<td><code class="notranslate">inet_ntop</code></td>
<td>网络字节序整数 → 字符串 IP</td>
<td>- <code class="notranslate">af</code>：地址族<br>- <code class="notranslate">src</code>：整数形式的 IP<br>- <code class="notranslate">dst</code>：存储字符串的缓冲区<br>- <code class="notranslate">cnt</code>：缓冲区大小（可用宏<code class="notranslate">INET_ADDRSTRLEN</code>（IPv4，16 字节）/<code class="notranslate">INET6_ADDRSTRLEN</code>（IPv6，46 字节））</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>关键结论</p>
<ul>
<li>旧版函数（<code class="notranslate">inet_addr</code>/<code class="notranslate">inet_aton</code>/<code class="notranslate">inet_ntoa</code>）仅支持 IPv4，且<code class="notranslate">inet_ntoa</code>不可重入；</li>
<li>新版函数（<code class="notranslate">inet_pton</code>/<code class="notranslate">inet_ntop</code>）是更推荐的方式：支持 IPv4/IPv6，无不可重入问题，兼容性更好。</li>
</ul>
<h1>2.创建socket</h1>
<p>一、<code class="notranslate">socket()</code>的核心定位<br>
在 UNIX/Linux 中，<strong>套接字（socket）是一种文件描述符</strong>，遵循 “一切皆文件” 的设计：可以像操作文件一样对 socket 执行读、写、控制、关闭等操作。<br>
二、<code class="notranslate">socket()</code>函数的定义与头文件<br>
运行</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/types.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-smi">int</span> <span class="pl-en">socket</span>( <span class="pl-smi">int</span> <span class="pl-s1">domain</span>, <span class="pl-smi">int</span> <span class="pl-s1">type</span>, <span class="pl-smi">int</span> <span class="pl-s1">protocol</span> );</pre></div>
<ul>
<li>成功返回：<strong>socket 对应的文件描述符</strong>（非负整数）；</li>
<li>失败返回：<code class="notranslate">-1</code>，并设置<code class="notranslate">errno</code>（错误标识）。<br>
三、<code class="notranslate">socket()</code>的三个参数详解</li>
</ul>
<ol>
<li><code class="notranslate">domain</code>：协议族（底层协议类型）<br>
作用：指定 socket 使用的<strong>协议族</strong>，决定了地址结构的类型。<br>
常见取值：</li>
</ol>
<ul>
<li><code class="notranslate">PF_INET</code>：TCP/IPv4 协议族；</li>
<li><code class="notranslate">PF_INET6</code>：TCP/IPv6 协议族；</li>
<li><code class="notranslate">PF_UNIX</code>：UNIX 本地域协议族（用于本机进程通信）。</li>
</ul>
<ol start="2">
<li><code class="notranslate">type</code>：服务类型（套接字类型）<br>
作用：指定 socket 的<strong>通信类型</strong>，决定了传输层协议的特性。<br>
核心取值：</li>
</ol>
<ul>
<li><code class="notranslate">SOCK_STREAM</code>：流服务，对应<strong>TCP 协议</strong>（可靠、面向连接、有序）；</li>
<li><code class="notranslate">SOCK_DGRAM</code>：数据报服务，对应<strong>UDP 协议</strong>（不可靠、无连接、快速）。<br>
<strong>扩展标志（Linux 2.6.17 + 支持）</strong>：<br>
可通过 “按位与” 添加额外属性：</li>
<li><code class="notranslate">SOCK_NONBLOCK</code>：将 socket 设为<strong>非阻塞模式</strong>（默认是阻塞）；</li>
<li><code class="notranslate">SOCK_CLOEXEC</code>：<code class="notranslate">fork</code>创建子进程时，自动在子进程中关闭该 socket。</li>
</ul>
<ol>
<li><code class="notranslate">protocol</code>：具体协议<br>
作用：在前两个参数确定的协议集合中，选择具体协议。</li>
</ol>
<ul>
<li>通常设为<code class="notranslate">0</code>：表示使用<code class="notranslate">domain+type</code>对应的<strong>默认协议</strong>（因为前两个参数已唯一确定协议，比如<code class="notranslate">PF_INET+SOCK_STREAM</code>的默认协议是 TCP）；</li>
<li>特殊场景才需指定非 0 值（极少用）。</li>
</ul>
<h1>3.命名socket</h1>
<p>一、<code class="notranslate">bind()</code>的核心作用</p>
<ul>
<li><strong>定义</strong>：将套接字（<code class="notranslate">sockfd</code>）与具体的<code class="notranslate">socket地址</code>绑定，相当于给套接字 “命名”；</li>
<li><strong>场景</strong>：
<ul>
<li>服务器必须调用<code class="notranslate">bind()</code>：绑定 IP + 端口后，客户端才能通过该地址连接服务器；</li>
<li>客户端通常不需要：由操作系统自动分配匿名地址。<br>
二、<code class="notranslate">bind()</code>函数的定义与头文件</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/types.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-smi">int</span> <span class="pl-en">bind</span>( <span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">sockaddr</span><span class="pl-c1">*</span> <span class="pl-s1">my_addr</span>, <span class="pl-smi">socklen_t</span> <span class="pl-s1">addrlen</span> );
<span class="pl-c">//例如：ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));</span></pre></div>
<ul>
<li>参数：
<ul>
<li><code class="notranslate">sockfd</code>：待绑定的套接字文件描述符；</li>
<li><code class="notranslate">my_addr</code>：要绑定的<code class="notranslate">socket地址</code>（需强转为通用结构<code class="notranslate">struct sockaddr*</code>）；</li>
<li><code class="notranslate">addrlen</code>：<code class="notranslate">my_addr</code>对应的地址结构长度；</li>
</ul>
</li>
<li>返回值：成功返回<code class="notranslate">0</code>，失败返回<code class="notranslate">-1</code>并设置<code class="notranslate">errno</code>。<br>
三、常见错误码（<code class="notranslate">errno</code>）</li>
</ul>
<ol>
<li><strong><code class="notranslate">EACCES</code></strong>：
<ul>
<li>原因：绑定的地址是 “受保护地址”，普通用户无权限；</li>
<li>典型场景：普通用户绑定<code class="notranslate">0~1023</code>的知名端口（如 80、443）。</li>
</ul>
</li>
<li><strong><code class="notranslate">EADDRINUSE</code></strong>：
<ul>
<li>原因：绑定的地址正在被使用；</li>
<li>典型场景：地址处于<code class="notranslate">TIME_WAIT</code>状态（服务器刚关闭，端口未释放）。</li>
</ul>
</li>
</ol>
<h1>4.监听socket</h1>
<p>一、<code class="notranslate">listen()</code>的核心作用<br>
<code class="notranslate">socket</code>被<code class="notranslate">bind()</code>命名后，需调用<code class="notranslate">listen()</code>将其转为<strong>被动监听状态</strong>，并创建<strong>监听队列</strong>来存放待处理的客户端连接 —— 只有调用<code class="notranslate">listen()</code>后，服务器才能通过<code class="notranslate">accept()</code>接收客户端连接。<br>
二、<code class="notranslate">listen()</code>函数的定义与头文件</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-smi">int</span> <span class="pl-en">listen</span>( <span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-smi">int</span> <span class="pl-s1">backlog</span> );</pre></div>
<ul>
<li>参数：
<ul>
<li><code class="notranslate">sockfd</code>：待监听的套接字文件描述符；</li>
<li><code class="notranslate">backlog</code>：监听队列的最大长度（用于限制待处理的连接数）；</li>
</ul>
</li>
<li>返回值：成功返回<code class="notranslate">0</code>，失败返回<code class="notranslate">-1</code>并设置<code class="notranslate">errno</code>。<br>
三、<code class="notranslate">backlog</code>参数的含义（Linux 内核版本差异）<br>
<code class="notranslate">backlog</code>限制的是 “待处理连接的数量”，但不同内核版本定义不同：</li>
</ul>
<ol>
<li><strong>内核 2.2 之前</strong>：<code class="notranslate">backlog</code>是 “半连接（<code class="notranslate">SYN_RCVD</code>）+ 完全连接（<code class="notranslate">ESTABLISHED</code>）” 的总数上限；</li>
<li><strong>内核 2.2 之后</strong>：<code class="notranslate">backlog</code>仅限制 “完全连接（<code class="notranslate">ESTABLISHED</code>）” 的数量；半连接的上限由内核参数<code class="notranslate">/proc/sys/net/ipv4/tcp_max_syn_backlog</code>控制。</li>
</ol>
<ul>
<li>典型值：<code class="notranslate">5</code>；实际中完全连接的上限通常是<code class="notranslate">backlog+1</code>（如示例中<code class="notranslate">backlog=5</code>时，完全连接最多 6 个）。<br>
四、超出<code class="notranslate">backlog</code>的后果<br>
若监听队列中待处理的连接数超过<code class="notranslate">backlog</code>，服务器会<strong>拒绝新连接</strong>，客户端会收到<code class="notranslate">ECONNREFUSED</code>错误。</li>
</ul>
<h1>5.接受连接</h1>
<p>一、<code class="notranslate">accept()</code>的核心逻辑<br>
<code class="notranslate">accept()</code>是从<strong>监听队列</strong>中取出一个已完成三次握手的连接，返回一个<strong>新的连接 socket</strong>（用于和客户端通信），同时通过<code class="notranslate">addr</code>参数获取客户端的远端地址。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106095616.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106095616.png" alt="image.png" style="max-width: 100%;"></a><br>
二、核心特性</p>
<ul>
<li><strong>职责单一</strong>：只从「完全连接队列」取连接，不参与三次握手，不验证连接有效性；</li>
<li><strong>无感知性</strong>：客户端即使异常断开（断网 / 退出），只要连接已进入完全连接队列，<code class="notranslate">accept()</code>就会成功返回；</li>
<li><strong>状态不影响</strong>：连接 socket 的状态（<code class="notranslate">ESTABLISHED</code>/<code class="notranslate">CLOSE_WAIT</code>）不影响<code class="notranslate">accept()</code>的返回结果；</li>
<li><strong>真正的断连检测</strong>：服务器必须通过<code class="notranslate">read()</code>/<code class="notranslate">write()</code>操作才能发现客户端断开：
<ul>
<li><code class="notranslate">read(connfd, buf, len)</code>返回<code class="notranslate">0</code> → 客户端正常断开（发了 FIN 包）；</li>
<li><code class="notranslate">read()</code>返回<code class="notranslate">-1</code>且<code class="notranslate">errno=ECONNRESET</code> → 客户端异常断开（比如强制杀死进程）；</li>
<li><code class="notranslate">write()</code>返回<code class="notranslate">-1</code>且<code class="notranslate">errno=EPIPE</code> → 客户端已断开，写数据失败。<br>
三、三次握手的发生<br>
我们以<code class="notranslate">testaccept</code>的实验场景为例，拆解每一步的时机：</li>
</ul>
</li>
</ul>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>时间阶段</th>
<th>服务器行为（应用层）</th>
<th>客户端行为（应用层）</th>
<th>内核行为（三次握手核心）</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶段 1：服务器准备</td>
<td>调用<code class="notranslate">socket()</code>创建监听 socket → <code class="notranslate">bind()</code>绑定地址 → <code class="notranslate">listen()</code>进入监听状态（LISTEN）</td>
<td>无</td>
<td>服务器内核初始化 “半连接队列”“完全连接队列”，等待客户端连接请求</td>
</tr>
<tr>
<td>阶段 2：客户端发起连接</td>
<td>服务器处于<code class="notranslate">sleep(20)</code>（应用层暂停，内核仍在工作）</td>
<td>调用<code class="notranslate">telnet</code>（本质是<code class="notranslate">connect()</code>）</td>
<td>1. 客户端内核发<strong>SYN 包</strong>给服务器 → 客户端进入<code class="notranslate">SYN_SENT</code>状态；<br><br>2. 服务器内核收到 SYN 包 → 发<strong>SYN+ACK 包</strong>给客户端 → 服务器该连接进入<code class="notranslate">SYN_RCVD</code>状态（加入半连接队列）；<br><br>3. 客户端内核收到 SYN+ACK 包 → 发<strong>ACK 包</strong>给服务器 → 客户端进入<code class="notranslate">ESTABLISHED</code>状态；<br><br>✅ 三次握手完成！</td>
</tr>
<tr>
<td>阶段 3：连接入队</td>
<td>服务器仍在<code class="notranslate">sleep(20)</code></td>
<td>客户端可能断网 / 退出（应用层操作）</td>
<td>服务器内核将这个 “完成三次握手的连接” 从半连接队列移到<strong>完全连接队列</strong> → 连接状态变为<code class="notranslate">ESTABLISHED</code></td>
</tr>
<tr>
<td>阶段 4：服务器取连接</td>
<td>服务器<code class="notranslate">sleep</code>结束 → 调用<code class="notranslate">accept()</code></td>
<td>客户端已断连 / 退出（应用层）</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>细节：三次握手的触发点</p>
<ul>
<li>客户端：调用<code class="notranslate">connect()</code> → 内核立刻发起 SYN 包，触发三次握手；</li>
<li>服务器：调用<code class="notranslate">listen()</code>后，内核才具备 “接收 SYN 包、完成握手” 的能力（没调用<code class="notranslate">listen()</code>的话，服务器内核会直接丢弃客户端的 SYN 包）。</li>
</ul>
<ol start="2">
<li>三次握手和<code class="notranslate">accept()</code>的关系</li>
</ol>
<ul>
<li>三次握手 <strong>先完成</strong>，连接才会进入 “完全连接队列”；</li>
<li><code class="notranslate">accept()</code>只是 “从队列里取连接”，<strong>不参与、也不等待</strong> 三次握手 —— 哪怕<code class="notranslate">accept()</code>还没调用，只要三次握手完成，连接就会在队列里等着。</li>
</ul>
<h1>6.发起连接</h1>
<p>客户端通过<code class="notranslate">connect()</code><strong>主动向服务器发起 TCP 连接请求</strong>，是客户端建立网络通信的关键调用（对应服务器的<code class="notranslate">listen()</code>/<code class="notranslate">accept()</code>）。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106101211.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106101211.png" alt="image.png" style="max-width: 100%;"></a></p>
<ul>
<li><code class="notranslate">sockfd</code>：客户端调用<code class="notranslate">socket()</code>创建的套接字文件描述符（未绑定地址时，由系统自动分配匿名地址）；</li>
<li><code class="notranslate">serv_addr</code>：服务器的<code class="notranslate">socket地址</code>（包含服务器的 IP 和端口，需强转为通用结构<code class="notranslate">struct sockaddr*</code>）；</li>
<li><code class="notranslate">addrlen</code>：<code class="notranslate">serv_addr</code>对应的地址结构长度；</li>
<li>客户端调用<code class="notranslate">connect()</code>后，内核会自动完成<strong>TCP 三次握手</strong>（和服务器内核交互 SYN/ACK 包）；</li>
<li>连接建立成功后，<code class="notranslate">sockfd</code>就唯一标识了 “客户端与服务器的这条连接”，客户端可通过<code class="notranslate">read()</code>/<code class="notranslate">write()</code>读写<code class="notranslate">sockfd</code>与服务器通信。<br>
常见错误码</li>
<li><strong><code class="notranslate">ECONNREFUSED</code></strong>：
<ul>
<li>原因：服务器的目标端口未被监听（比如服务器没启动，或端口号错误），连接被服务器内核拒绝；</li>
</ul>
</li>
<li><strong><code class="notranslate">ETIMEDOUT</code></strong>：
<ul>
<li>原因：连接超时（比如服务器无响应、网络故障，导致三次握手无法完成）。</li>
</ul>
</li>
</ul>
<p><strong>sockfd在connect和accept区别</strong></p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>对比维度</th>
<th>connect中的sockfd（客户端）</th>
<th>accept中的sockfd（服务器）</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属端</td>
<td>客户端的套接字</td>
<td>服务器的套接字</td>
</tr>
<tr>
<td>职责</td>
<td>代表 “客户端与服务器的这条连接”，用于和服务器通信</td>
<td>代表 “服务器与某一个客户端的这条连接”，用于和该客户端通信</td>
</tr>
<tr>
<td>来源</td>
<td>客户端调用socket()直接创建（无需bind/listen）</td>
<td>服务器调用accept()后新返回的套接字（不是监听 socket）</td>
</tr>
<tr>
<td>与监听 socket 的关系</td>
<td>无（客户端没有监听 socket）</td>
<td>由服务器的监听 socket（listen()后的 socket）触发生成</td>
</tr>
<tr>
<td>数量</td>
<td>客户端通常只有 1 个（对应一条连接）</td>
<td>服务器会有多个（每accept一个客户端连接，就生成一个新的sockfd）</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h1>7.关闭连接</h1>
<p>一、<code class="notranslate">close</code>：通用的文件描述符关闭（适用于 socket，但有局限性）</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;unistd.h&gt;</span>
<span class="pl-smi">int</span> <span class="pl-en">close</span>(<span class="pl-smi">int</span> <span class="pl-s1">fd</span>);</pre></div>
<ul>
<li><strong>核心逻辑</strong>：<br>
<code class="notranslate">close</code>是通用的 “关闭文件描述符” 调用，对 socket 来说，它的本质是<strong>将 socket 的 “引用计数” 减 1</strong>—— 只有当引用计数变为 0 时，才会真正关闭连接。</li>
<li><strong>多进程场景的坑</strong>：<br>
若父进程<code class="notranslate">fork</code>子进程，子进程会继承父进程的 socket，导致该 socket 的引用计数 + 1。此时必须<strong>父、子进程都调用<code class="notranslate">close</code></strong>，才能让引用计数归 0，真正关闭连接。</li>
<li><strong>局限性</strong>：<br>
无法单独关闭 “读” 或 “写”，只能同时关闭 socket 的读写能力。<br>
二、<code class="notranslate">shutdown</code>：专门为网络设计的连接关闭（更灵活）</li>
</ul>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-smi">int</span> <span class="pl-en">shutdown</span>(<span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-smi">int</span> <span class="pl-s1">howto</span>);</pre></div>
<ul>
<li><strong>核心逻辑</strong>：<br>
专门针对 socket 设计，直接操作连接本身（不依赖引用计数），可以<strong>单独关闭连接的 “读” 或 “写”</strong>，<code class="notranslate">howto</code>参数决定行为：<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106102456.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106102456.png" alt="image.png" style="max-width: 100%;"></a></li>
<li><strong>优势</strong>：<br>
不受引用计数影响，即使 socket 被多进程共享，调用<code class="notranslate">shutdown</code>也能直接关闭连接的对应方向；且支持 “半关闭”（比如只关闭写，仍能读对方数据）。<br>
三、<code class="notranslate">close</code> vs <code class="notranslate">shutdown</code>的核心区别</li>
</ul>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>维度</th>
<th><code class="notranslate">close</code></th>
<th><code class="notranslate">shutdown</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖引用计数</td>
<td>是（计数归 0 才关）</td>
<td>否（直接操作连接）</td>
</tr>
<tr>
<td>支持半关闭</td>
<td>否（只能同时关读写）</td>
<td>是（可单独关读 / 写）</td>
</tr>
<tr>
<td>适用场景</td>
<td>单进程、简单关闭</td>
<td>多进程、需要灵活控制读写的场景</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>四、注意客户端和服务器的区别<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106102954.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106102954.png" alt="image.png" style="max-width: 100%;"></a><br>
五、注意监听socket和连接socket区别<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106103221.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106103221.png" alt="image.png" style="max-width: 100%;"></a><br>
举个直观例子：</p>
<ul>
<li>服务器启动：创建<code class="notranslate">listenfd</code>（引用数 = 1），监听 54321 端口；</li>
<li>客户端 A 连接：服务器<code class="notranslate">accept</code>得到<code class="notranslate">connfd1</code>（引用数 = 1），和 A 通信；</li>
<li>客户端 B 连接：服务器<code class="notranslate">accept</code>得到<code class="notranslate">connfd2</code>（引用数 = 1），和 B 通信；</li>
<li>服务器调用<code class="notranslate">close(listenfd)</code>：<code class="notranslate">listenfd</code>引用数 = 0 → 停止监听 54321 端口（新客户端连不上），但 A、B 的<code class="notranslate">connfd1</code>/<code class="notranslate">connfd2</code>仍正常，和 A、B 的通信不受影响；</li>
<li>服务器再调用<code class="notranslate">close(connfd1)</code>：<code class="notranslate">connfd1</code>引用数 = 0 → 断开和 A 的连接，B 的<code class="notranslate">connfd2</code>仍正常。<br>
总结<br>
✅ 服务器调用<code class="notranslate">close(listenfd)</code>时，<strong>监听 socket 的引用数会减 1</strong>（规则和连接 socket 一致）；<br>
✅ 监听 socket 和连接 socket 的引用数完全独立，关闭其中一个不会影响另一个的引用数；<br>
✅ 关闭监听 socket 只会停止接收新连接，不会断开已建立的客户端连接。</li>
</ul>
<h1>8.数据读写</h1>
<h2>8.1 TCP数据读写</h2>
<p>一、TCP 数据读写：<code class="notranslate">recv</code>/<code class="notranslate">send</code></p>
<ol>
<li><strong>通用接口兼容</strong>：<br>
对 socket 的读写可以直接用<code class="notranslate">read</code>/<code class="notranslate">write</code>（因为 UNIX “一切皆文件”），但<code class="notranslate">socket</code>提供了更灵活的专用接口<code class="notranslate">recv</code>/<code class="notranslate">send</code>。</li>
<li><strong><code class="notranslate">recv</code>/<code class="notranslate">send</code>的定义</strong>：
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/types.h&gt;</span>
<span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-smi">ssize_t</span> <span class="pl-en">recv</span>(<span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">len</span>, <span class="pl-smi">int</span> <span class="pl-s1">flags</span>);
<span class="pl-smi">ssize_t</span> <span class="pl-en">send</span>(<span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-k">const</span> <span class="pl-smi">void</span> <span class="pl-c1">*</span><span class="pl-s1">buf</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">len</span>, <span class="pl-smi">int</span> <span class="pl-s1">flags</span>);</pre></div>
<ul>
<li><code class="notranslate">flags</code>参数是核心：提供额外的读写控制（如非阻塞、带外数据等），默认填<code class="notranslate">0</code>时效果等同于<code class="notranslate">read</code>/<code class="notranslate">write</code>。</li>
</ul>
</li>
<li><strong><code class="notranslate">recv</code>的返回值含义</strong>：
<ul>
<li>正数：实际读取的字节数（可能小于<code class="notranslate">len</code>，需循环读取）；</li>
<li><code class="notranslate">0</code>：对方关闭连接；</li>
<li><code class="notranslate">-1</code>：出错（需检查<code class="notranslate">errno</code>）。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106105256.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260106105256.png" alt="image.png" style="max-width: 100%;"></a></li>
</ul>
</li>
</ol>
<p>二、示例：带外数据的发送与接收</p>
<ol>
<li>客户端代码（<code class="notranslate">testoobsend</code>）逻辑：</li>
</ol>
<ul>
<li>创建 socket 并连接服务器；</li>
<li>发送<strong>正常数据</strong><code class="notranslate">"123"</code>（<code class="notranslate">flags=0</code>）；</li>
<li>发送<strong>带外数据</strong><code class="notranslate">"abc"</code>（<code class="notranslate">flags=MSG_OOB</code>）；</li>
<li>发送<strong>正常数据</strong><code class="notranslate">"123"</code>（<code class="notranslate">flags=0</code>）。</li>
</ul>
<ol start="2">
<li>服务器代码（<code class="notranslate">testoobrecv</code>）逻辑：</li>
</ol>
<ul>
<li>创建监听 socket，<code class="notranslate">accept</code>客户端连接；</li>
<li>用<code class="notranslate">flags=0</code>读取正常数据；</li>
<li>用<code class="notranslate">flags=MSG_OOB</code>读取带外数据；</li>
<li>用<code class="notranslate">flags=0</code>读取剩余正常数据。</li>
</ul>
<ol start="3">
<li>实验结果与关键结论：<br>
服务器输出：</li>
</ol>
<pre lang="plaintext" class="notranslate"><code class="notranslate">got 5 bytes of normal data '123ab'
got 1 bytes of oob data 'c'
got 3 bytes of normal data '123'
</code></pre>
<ul>
<li><strong>带外数据的 “单字节特性”</strong>：<br>
客户端发送的 3 字节带外数据<code class="notranslate">"abc"</code>，服务器仅收到最后 1 字节<code class="notranslate">"c"</code>—— 因为 TCP 的带外数据是<strong>1 字节的紧急数据</strong>（紧急偏移指向最后 1 字节），实际只能传递 1 个字节的紧急信息。</li>
<li><strong>带外数据会截断正常数据</strong>：<br>
正常数据<code class="notranslate">"123"</code>和带外数据的前 2 字节<code class="notranslate">"ab"</code>被合并为<code class="notranslate">"123ab"</code>，说明带外数据会插入到正常数据流中，导致正常数据被截断，无法通过一次<code class="notranslate">recv</code>读取完整。</li>
</ul>
<h2>8.2 UDP数据读写</h2>
<p>一、UDP 数据读写的专用系统调用<br>
UDP 是无连接的协议，因此读写数据时需要<strong>明确指定通信对方的地址</strong>，对应的系统调用是：</p>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">#include</span> <span class="pl-s">&lt;sys/socket.h&gt;</span>
<span class="pl-c">// 读取UDP数据（同时获取发送端地址）</span>
<span class="pl-smi">ssize_t</span> <span class="pl-en">recvfrom</span>(<span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-smi">void</span><span class="pl-c1">*</span> <span class="pl-s1">buf</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">len</span>, <span class="pl-smi">int</span> <span class="pl-s1">flags</span>, 
                 <span class="pl-k">struct</span> <span class="pl-smi">sockaddr</span><span class="pl-c1">*</span> <span class="pl-s1">src_addr</span>, <span class="pl-smi">socklen_t</span><span class="pl-c1">*</span> <span class="pl-s1">addrlen</span>);
<span class="pl-c">// 发送UDP数据（指定接收端地址）</span>
<span class="pl-smi">ssize_t</span> <span class="pl-en">sendto</span>(<span class="pl-smi">int</span> <span class="pl-s1">sockfd</span>, <span class="pl-k">const</span> <span class="pl-smi">void</span><span class="pl-c1">*</span> <span class="pl-s1">buf</span>, <span class="pl-smi">size_t</span> <span class="pl-s1">len</span>, <span class="pl-smi">int</span> <span class="pl-s1">flags</span>, 
               <span class="pl-k">const</span> <span class="pl-k">struct</span> <span class="pl-smi">sockaddr</span><span class="pl-c1">*</span> <span class="pl-s1">dest_addr</span>, <span class="pl-smi">socklen_t</span> <span class="pl-s1">addrlen</span>);</pre></div>
<p>二、核心参数与逻辑（适配 UDP 的无连接特性）</p>
<ol>
<li><strong><code class="notranslate">recvfrom</code>（读）</strong>：
<ul>
<li>因为 UDP 无连接，每次读数据都需要通过<code class="notranslate">src_addr</code>获取<strong>发送端的 socket 地址</strong>（IP + 端口）；</li>
<li><code class="notranslate">addrlen</code>需先初始化（传入<code class="notranslate">src_addr</code>的内存大小），内核会返回实际地址长度。</li>
</ul>
</li>
<li><strong><code class="notranslate">sendto</code>（写）</strong>：
<ul>
<li>因为 UDP 无连接，每次写数据都需要通过<code class="notranslate">dest_addr</code>指定<strong>接收端的 socket 地址</strong>（IP + 端口）；</li>
<li><code class="notranslate">addrlen</code>是<code class="notranslate">dest_addr</code>的地址长度<br>
三、与 TCP 读写接口的关联</li>
</ul>
</li>
</ol>
<ul>
<li><code class="notranslate">recvfrom</code>/<code class="notranslate">sendto</code>的<code class="notranslate">flags</code>参数、返回值含义，和 TCP 的<code class="notranslate">recv</code>/<code class="notranslate">send</code>完全一致（比如<code class="notranslate">flags=0</code>是默认行为，返回值是实际读写字节数）；</li>
<li>这两个接口<strong>也可以用于 TCP（面向连接的 socket）</strong>：只需将<code class="notranslate">src_addr</code>/<code class="notranslate">dest_addr</code>设为<code class="notranslate">NULL</code>（因为 TCP 已建立连接，地址已知），此时效果等同于<code class="notranslate">recv</code>/<code class="notranslate">send</code>。<br>
关键结论</li>
</ul>
<ol>
<li>UDP 的无连接特性，决定了其读写必须通过<code class="notranslate">recvfrom</code>/<code class="notranslate">sendto</code>明确处理通信地址；</li>
<li><code class="notranslate">recvfrom</code>/<code class="notranslate">sendto</code>是通用接口，既支持 UDP（无连接），也支持 TCP（面向连接）；</li>
<li>核心区别：UDP 用这两个接口处理 “动态地址”，TCP 用它们时可以忽略地址参数。</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://waibibab-cs.github.io">waibibab's blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","waibibab-cs/waibibab-cs.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
